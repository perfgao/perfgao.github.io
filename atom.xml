<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>perfgao</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.perfgao.xin/"/>
  <updated>2018-03-28T13:34:42.240Z</updated>
  <id>http://www.perfgao.xin/</id>
  
  <author>
    <name>perfgao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx的时间管理</title>
    <link href="http://www.perfgao.xin/2017/04/04/ngx_time_manege/"/>
    <id>http://www.perfgao.xin/2017/04/04/ngx_time_manege/</id>
    <published>2017-04-04T14:09:10.000Z</published>
    <updated>2018-03-28T13:34:42.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要以work进程为主要研究对象，研究其在epoll模式下的时间管理逻辑。</p><h2 id="时间缓存"><a href="#时间缓存" class="headerlink" title="时间缓存"></a>时间缓存</h2><p>nginx 为尽量减少性能损耗，对时间的管理，采用了自己对时间进行缓存，以减少系统调用次数(时间更新使用gettimeofday函数)。这样做也是因为服务器基本对时间的精确度有个容忍度。</p><h2 id="三类事件触发时间更新"><a href="#三类事件触发时间更新" class="headerlink" title="三类事件触发时间更新"></a>三类事件触发时间更新</h2><ul><li>网络IO事件</li><li>超时事件</li><li>定时事件</li></ul><a id="more"></a><h2 id="关于指令timer-resolution"><a href="#关于指令timer-resolution" class="headerlink" title="关于指令timer_resolution"></a>关于指令timer_resolution</h2><p>work进程对时间的更新在每次的epool_wait结束。在没有配置timer_resolution时，是通过网络IO事件和超时事件来触发更新。这种情况下时间的更新就与网络IO事件和超时事件息息相关。在某些情况下，比如没有超时事件注册，且没有网络IO事件发生，epoll_wait有会一直等待。想要准确的更新时间，nginx就提供了指令timer_resolution来设置获取时间的周期值。当配置了timer_resolution时，则是通过定时事件来触发时间更新的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_resolution 100ms;</span><br></pre></td></tr></table></figure><p>即是通过指定参数来设置更新频率。这种情况下，epoll_wait会阻塞等待一直到读写事件发生或则信号中断(注意此时没有超时时间)。<br><br>另外，看过一些资料说现在x86_64对gettimeofday函数的调用开销很小，所以在配置nginx时可以根据需要来决定是否配置该指令或设定适当更新时间的间隔。</p><h2 id="从未配置timer-resolution谈起"><a href="#从未配置timer-resolution谈起" class="headerlink" title="从未配置timer_resolution谈起"></a>从未配置timer_resolution谈起</h2><p>nginx在master/workers下，每个进程都会维护自己的时间。这里主要看下work进程的时间管理逻辑。工作进程的主要工作函数在ngx_worker_process_cycle:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)</span><br><span class="line">&#123;</span><br><span class="line">    for ( ;; ) &#123;</span><br><span class="line"></span><br><span class="line">        ngx_process_events_and_timers(cycle);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个子进程在进行一系列初始化工作之后，会进入到处理事件的循环中。<br>在循环中会调用 ngx_process_events_and_timers;<br>该函数是工作进程的核心函数，这里主要看时间相关的逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">ngx_process_events_and_timers(ngx_cycle_t *cycle)</span><br><span class="line">&#123;</span><br><span class="line">    if (ngx_timer_resolution) &#123;</span><br><span class="line">        timer = NGX_TIMER_INFINITE;  // 宏，值为 -1</span><br><span class="line">        flags = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        timer = ngx_event_find_timer(); //获取离现在最近的超时定时器时间</span><br><span class="line">        flags = NGX_UPDATE_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (void) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>她会对ngx_timer_resolution进行判断(注意：配置了timer_resolution，则ngx_timer_resolution为配置的时间值，<strong>未配置则ngx_timer_resolution值为0</strong>). <br><br>在没有配置情况下，通过ngx_event_find_timer获取最近的超时时间,flag赋值为NGX_UPDATE_TIME。之后传入ngx_process_events中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(void) ngx_process_events(cycle, timer, flags);</span><br></pre></td></tr></table></figure></p><p>它是一个钩子函数。linux下，nginx use epoll下，事件为普通网络IO套接字，则调用为：<strong>ngx_epoll_process_events</strong>;<br><br>事件为异步文件i/o，则调用为： <strong>ngx_epoll_eventfd_handler</strong></p><p>这里主要看下在ngx_epoll_process_events：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static ngx_int_t</span><br><span class="line">ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    events = epoll_wait(ep, event_list, (int) nevents, timer);</span><br><span class="line"></span><br><span class="line">    if (flags &amp; NGX_UPDATE_TIME || ngx_event_timer_alarm) &#123;</span><br><span class="line">        ngx_time_update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; events; i++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在ngx_epoll_process_events中会调用epoll_wait. 在没有设置 ngx_timer_resolution情况下，则传入的timer为获取的最近的超时时间，这样在epoll_wait即使没有读写事件发生，也会触发超时。不管是读写事件还是超时事件，都会因为传入的flag为NGX_UPDATE_TIME，而进行时间的更新。</p><h2 id="配置timer-resolution下的时间管理"><a href="#配置timer-resolution下的时间管理" class="headerlink" title="配置timer_resolution下的时间管理"></a>配置timer_resolution下的时间管理</h2><p>这种情况下的时间更新逻辑，要从子进程创建开始：<br>nginx在创建子进程时，每个子进程初始化时会调用：<br><strong>ngx_event_process_init()</strong>;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static ngx_int_t</span><br><span class="line">ngx_event_process_init(ngx_cycle_t *cycle)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (ngx_timer_resolution &amp;&amp; !(ngx_event_flags &amp; NGX_USE_TIMER_EVENT)) &#123;</span><br><span class="line">        struct sigaction  sa;</span><br><span class="line">        struct itimerval  itv;</span><br><span class="line"></span><br><span class="line">        ngx_memzero(&amp;sa, sizeof(struct sigaction));</span><br><span class="line"></span><br><span class="line">        sa.sa_handler = ngx_timer_signal_handler;</span><br><span class="line">        sigemptyset(&amp;sa.sa_mask);</span><br><span class="line"></span><br><span class="line">        if (sigaction(SIGALRM, &amp;sa, NULL) == -1) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno,</span><br><span class="line">                          &quot;sigaction(SIGALRM) failed&quot;);</span><br><span class="line">            return NGX_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        itv.it_interval.tv_sec = ngx_timer_resolution / 1000;</span><br><span class="line">        itv.it_interval.tv_usec = (ngx_timer_resolution % 1000) * 1000;</span><br><span class="line">        itv.it_value.tv_sec = ngx_timer_resolution / 1000;</span><br><span class="line">        itv.it_value.tv_usec = (ngx_timer_resolution % 1000 ) * 1000;</span><br><span class="line"></span><br><span class="line">        if (setitimer(ITIMER_REAL, &amp;itv, NULL) == -1) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno,</span><br><span class="line">                          &quot;setitimer() failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   这里就会判断，若是指定了更新时间值，则该进程会设置一个定时器，并设置该进程的信号处理函数为<strong>ngx_timer_signal_handler</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void  </span><br><span class="line">ngx_timer_signal_handler(int signo)  </span><br><span class="line">&#123;  </span><br><span class="line">    ngx_event_timer_alarm = 1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结合以上ngx_worker_process_cycle和ngx_process_events_and_timers逻辑，进入ngx_process_events_and_timers时，会把timer设置为-1,flag为0。即传入ngx_epoll_process_events的timer为-1,flag为0。timer为-1使epoll_wait为永远等待，直到有读写事件发生。当有读写事件发生后，又由于flag为0，且此时若是ngx_event_timer_alarm为0,则不可能进入到时间更新。<br><br>而当定时时间到达时，信号处理函数就会设置ngx_event_timer_alarm为1，同时SIGALRM信号会使处于等待的epoll_wait中断，这样便会更新时间了。</p><h2 id="最后在说下setitimer"><a href="#最后在说下setitimer" class="headerlink" title="最后在说下setitimer()"></a>最后在说下setitimer()</h2><p>setitimer(), 是linux的API函数。<br>它本身有两个作用：</p><ul><li>指定一段时间后才执行某个函数</li><li>指定每隔一段时间就执行某个函数 <br></li></ul><p>当setitimer到时就会触发SIGALRM信号。而是要完成哪种作用效果，<br>   则是struct itimerva的设置了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要以work进程为主要研究对象，研究其在epoll模式下的时间管理逻辑。&lt;/p&gt;
&lt;h2 id=&quot;时间缓存&quot;&gt;&lt;a href=&quot;#时间缓存&quot; class=&quot;headerlink&quot; title=&quot;时间缓存&quot;&gt;&lt;/a&gt;时间缓存&lt;/h2&gt;&lt;p&gt;nginx 为尽量减少性能损耗，对时间的管理，采用了自己对时间进行缓存，以减少系统调用次数(时间更新使用gettimeofday函数)。这样做也是因为服务器基本对时间的精确度有个容忍度。&lt;/p&gt;
&lt;h2 id=&quot;三类事件触发时间更新&quot;&gt;&lt;a href=&quot;#三类事件触发时间更新&quot; class=&quot;headerlink&quot; title=&quot;三类事件触发时间更新&quot;&gt;&lt;/a&gt;三类事件触发时间更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;网络IO事件&lt;/li&gt;
&lt;li&gt;超时事件&lt;/li&gt;
&lt;li&gt;定时事件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://www.perfgao.xin/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://www.perfgao.xin/tags/nginx/"/>
    
      <category term="timer" scheme="http://www.perfgao.xin/tags/timer/"/>
    
      <category term="时间管理" scheme="http://www.perfgao.xin/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>nginx 防止惊群</title>
    <link href="http://www.perfgao.xin/2017/03/24/jingqun/"/>
    <id>http://www.perfgao.xin/2017/03/24/jingqun/</id>
    <published>2017-03-24T10:43:21.000Z</published>
    <updated>2018-03-28T13:34:42.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="惊群"><a href="#惊群" class="headerlink" title="惊群"></a>惊群</h2><p> 惊群现象就是多个进程同时等待同一个事件，当有事件发生时，所有进程都被唤醒，同时去响应这个事件，最后只有一个进程能成功执行，而其他进程只能继续重新休眠。nginx 在master/workers模型下，多个worker进程进行epoll_wait，当有新的连接事件发生，会唤醒所有进程的epoll_wait，结果有些进程发现accpte是失败的。这样的话，开销变大，性能也会随之下降。</p><a id="more"></a><h2 id="nginx的解决方案"><a href="#nginx的解决方案" class="headerlink" title="nginx的解决方案"></a>nginx的解决方案</h2><p>解决这个问题的方案总结下来就是一句话：<br><strong>同一时刻只允许有一个worker进程将需要监听的句柄加入到自己的epoll中</strong>。</p><h2 id="accpet锁机制"><a href="#accpet锁机制" class="headerlink" title="accpet锁机制"></a>accpet锁机制</h2><p>通过使用加锁的机制，来做进程间的协调。如果开启了accept锁，则每个worker进程每次在进入epoll_wait获取事件之前，会进行尝试获取锁。只有获取到锁的worker进程才能将需要监听的句柄加入到自己的epoll中，进而去处理accpet事件。<br>不过，这里要注意几个逻辑：</p><ul><li>如果该worker进程获取锁成功：<ul><li>并且其<strong>上一次</strong>尝试获得锁是失败的（即上一次没有获得到锁），才会将现有的cycle-&gt;listening数组中需要监听的句柄加入到自己的epoll中，</li><li>要是<strong>上一次</strong>尝试获得锁也是成功的（即上一次该进程得到了锁，这次仍是该进程拥有），则会直接返回。</li></ul></li><li>如果该worker进程获取锁失败，<ul><li>并且其<strong>上一次</strong>尝试获得锁也是失败的，则会直接返回。</li><li>如果其<strong>上一次</strong>尝试获得锁是成功的，则会将现有的cycle-&gt;listening数组中已经监听的句柄从自己的epoll中移除。</li></ul></li></ul><h2 id="POST事件"><a href="#POST事件" class="headerlink" title="POST事件"></a>POST事件</h2><p>对于得到锁的进程，会携带<strong>NGX_POST_EVENTS</strong>标记属性。这样在epoll_wait后，会把需要处理的事件先加入到队列中，延迟处理，目的就是避免该进程长时间占有锁。<br>特别说明一下，这里的延迟队列分为两种：</p><ul><li>accept事件的延迟队列</li><li>read/write事件的延迟队列</li></ul><p>也就是对应的事件会加到对应的延迟队列中。进程在释放锁之前，会先处理accept事件的延迟队列，处理完后才会释放锁，然后再去处理超时事件和read/write事件的延迟队列，这样既保证的处理accpet的可靠性，也避免了长时间对锁的占用。</p><h2 id="未得到锁的进程"><a href="#未得到锁的进程" class="headerlink" title="未得到锁的进程"></a>未得到锁的进程</h2><p>与此同时，未得到锁的进程会在epoll_wait下至少等待ngx_accept_mutex_delay毫秒，因为有可能超时事件的发生时间会短与ngx_accept_mutex_delay，也有可能有普通的读写事件触发。总之，该进程会更新进程时间缓存，处理相关的事件。然后再次尝试锁的获取。</p><h2 id="指令-accept-mutex"><a href="#指令-accept-mutex" class="headerlink" title="指令 accept_mutex"></a>指令 accept_mutex</h2><ul><li>默认是打开。</li></ul><p>与它相关的指令：</p><ul><li>accept_mutex_delay – 默认 500 毫秒</li></ul><h2 id="看下代码逻辑实现"><a href="#看下代码逻辑实现" class="headerlink" title="看下代码逻辑实现"></a>看下代码逻辑实现</h2><ul><li>ngx_use_accept_mutex: 当开启了accept_mutex，且worker进程数 &gt; 1, ngx_use_accept_mutex会置为1</li><li>ngx_process_events 是一个函数指针。普通网络套接字调用ngx_epoll_process_events函数开始处理，异步文件i/o设置事件的回调方法为ngx_epoll_eventfd_handler。这里主要看下ngx_epoll_process_events函数逻辑。</li><li>注意：这里仅仅是为了方便阅读，只是展现了大概的代码逻辑，省略了部分代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">ngx_process_events_and_timers(ngx_cycle_t *cycle)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (ngx_use_accept_mutex) &#123;</span><br><span class="line"></span><br><span class="line">        if (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ngx_accept_mutex_held) &#123;</span><br><span class="line">            flags |= NGX_POST_EVENTS;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (timer == NGX_TIMER_INFINITE</span><br><span class="line">                    || timer &gt; ngx_accept_mutex_delay)</span><br><span class="line">            &#123;</span><br><span class="line">                timer = ngx_accept_mutex_delay;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (void) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line">    ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);</span><br><span class="line"></span><br><span class="line">    if (ngx_accept_mutex_held) &#123;</span><br><span class="line">        ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (delta) &#123;</span><br><span class="line">        ngx_event_expire_timers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_event_process_posted(cycle, &amp;ngx_posted_events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ngx_int_t</span><br><span class="line">ngx_trylock_accept_mutex(ngx_cycle_t *cycle)</span><br><span class="line">&#123;</span><br><span class="line">    if (ngx_shmtx_trylock(&amp;ngx_accept_mutex)) &#123;</span><br><span class="line"></span><br><span class="line">        if (ngx_accept_mutex_held &amp;&amp; ngx_accept_events == 0) &#123;</span><br><span class="line">            return NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ngx_enable_accept_events(cycle) == NGX_ERROR) &#123;</span><br><span class="line">            ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class="line">            return NGX_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngx_accept_events = 0;</span><br><span class="line">        ngx_accept_mutex_held = 1;  </span><br><span class="line"></span><br><span class="line">        return NGX_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_accept_mutex_held) &#123;</span><br><span class="line">        if (ngx_disable_accept_events(cycle, 0) == NGX_ERROR) &#123;</span><br><span class="line">            return NGX_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngx_accept_mutex_held = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static ngx_int_t</span><br><span class="line">ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    events = epoll_wait(ep, event_list, (int) nevents, timer);  </span><br><span class="line"></span><br><span class="line">    ngx_time_update();</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; events; i++) &#123;</span><br><span class="line"></span><br><span class="line">        if ((revents &amp; EPOLLIN) &amp;&amp; rev-&gt;active) &#123;</span><br><span class="line"></span><br><span class="line">            if (flags &amp; NGX_POST_EVENTS) &#123;</span><br><span class="line">                queue = rev-&gt;accept ? &amp;ngx_posted_accept_events</span><br><span class="line">                                    : &amp;ngx_posted_events;</span><br><span class="line"></span><br><span class="line">                ngx_post_event(rev, queue);</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rev-&gt;handler(rev);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((revents &amp; EPOLLOUT) &amp;&amp; wev-&gt;active) &#123;</span><br><span class="line"></span><br><span class="line">            if (flags &amp; NGX_POST_EVENTS) &#123;</span><br><span class="line">                ngx_post_event(wev, &amp;ngx_posted_events);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                wev-&gt;handler(wev);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;惊群&quot;&gt;&lt;a href=&quot;#惊群&quot; class=&quot;headerlink&quot; title=&quot;惊群&quot;&gt;&lt;/a&gt;惊群&lt;/h2&gt;&lt;p&gt; 惊群现象就是多个进程同时等待同一个事件，当有事件发生时，所有进程都被唤醒，同时去响应这个事件，最后只有一个进程能成功执行，而其他进程只能继续重新休眠。nginx 在master/workers模型下，多个worker进程进行epoll_wait，当有新的连接事件发生，会唤醒所有进程的epoll_wait，结果有些进程发现accpte是失败的。这样的话，开销变大，性能也会随之下降。&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://www.perfgao.xin/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://www.perfgao.xin/tags/nginx/"/>
    
      <category term="惊群" scheme="http://www.perfgao.xin/tags/%E6%83%8A%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>nginx事件驱动框架</title>
    <link href="http://www.perfgao.xin/2017/03/17/nginx%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.perfgao.xin/2017/03/17/nginx事件驱动框架/</id>
    <published>2017-03-17T10:34:23.000Z</published>
    <updated>2018-03-28T13:34:42.239Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要阐述个人对<strong>nginx</strong>的核心机制–事件驱动框架理解,分享自己的见得。也希望帮助相关爱好者更清除的了解nginx。文中如有不妥的地方，欢迎指导更正。</p><p>首先先了解下，目前流行的web server中，使用最广的Apache在处理请求时，主要是fork出子进程进行处理，其特征就是一个请求占用一个子进程，请求处理完后进程退出销毁。这种处理架构很明显地随着需要http连接增多对系统的资源占用也随之增加，并发能力不高。而对于nginx是如何做到高性能，高并发的呢–nginx的强大就是使用了事件驱动，也就是IO多路复用。对于nginx的几个worker进程而言，她们关注的是事件。（本文主要探讨的是linux环境下使用epoll模块的IO多路复用）</p><a id="more"></a><h3 id="网络IO处理"><a href="#网络IO处理" class="headerlink" title="网络IO处理"></a>网络IO处理</h3><p>使用epoll机制(本文主要探究epoll，对于freebsd的kqueue不做探究)。对网络请求的socket进行epoll监听，使用epoll_wait（在ET或LT模式下）来获取需要处理的事件。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>定时器是由红黑树构成，其中每个节点都是一个时间值。这样每次从树中取出一个最小值的节点与当前系统时间做对比，若是小于当期时间则是超时事件，便会触发相应的超时处理。</p><h3 id="事件的划分"><a href="#事件的划分" class="headerlink" title="事件的划分"></a>事件的划分</h3><p>对于accept成功的socket，之后应该是从客户端（浏览器）读取请求，读取请求的时候，若是请求体比较大，可能会经过几次的触发才能读取完。读取完后，就要与上游服务器建立连接，在tcp建立连接的三次握手过程中，加之复杂的网络环境（有可能建立需要花费较长的时间），nginx不可能阻塞着，这时候nginx会将socket加入到epoll中，并设定一个超时时间在定时器中。一旦在有效时间内上游服务器有回应了，便会触发接下来的继续执行。若是超时了，nginx就会进行连接超时的相关处理（此时若是使用的upstream，便会执行向其他上游服务ip的连接流程）。连接建立成功后，nginx会向上游发送请求。请求发送完后，便是接收上游发来的响应。这些过程中，nginx都不会阻塞着等待期待到来的事件发生，而都是加入到epoll中进行监听，并添加相应的超时事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n, ngx_int_t type)</span><br><span class="line">&#123;</span><br><span class="line">    for ( ;; ) &#123;</span><br><span class="line"></span><br><span class="line">        ngx_event_cancel_timers();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">ngx_process_events_and_timers(ngx_cycle_t *cycle)  </span><br><span class="line">&#123;</span><br><span class="line">    timer = ngx_event_find_timer();</span><br><span class="line"></span><br><span class="line">    (void) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line">    ngx_event_expire_timers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static ngx_int_t</span><br><span class="line">ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    events = epoll_wait(ep, event_list, (int) nevents, timer);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; events; i++) &#123;</span><br><span class="line">        if ((revents &amp; EPOLLIN) &amp;&amp; rev-&gt;active) &#123;</span><br><span class="line">            rev-&gt;handler(rev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((revents &amp; EPOLLOUT) &amp;&amp; wev-&gt;active) &#123;</span><br><span class="line">            wev-&gt;handler(wev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">ngx_event_expire_timers(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    sentinel = ngx_event_timer_rbtree.sentinel;</span><br><span class="line"></span><br><span class="line">    for ( ;; ) &#123;</span><br><span class="line">        root = ngx_event_timer_rbtree.root;</span><br><span class="line">        if (root == sentinel) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = ngx_rbtree_min(root, sentinel);</span><br><span class="line"></span><br><span class="line">        if ((ngx_msec_int_t) (node-&gt;key - ngx_current_msec) &gt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngx_rbtree_delete(&amp;ngx_event_timer_rbtree, &amp;ev-&gt;timer);</span><br><span class="line"></span><br><span class="line">        ev-&gt;timer_set = 0;</span><br><span class="line">        ev-&gt;timedout = 1;</span><br><span class="line">        ev-&gt;handler(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ngx_event_t 结构体中有一些标记位，不同的状态对应不同的标志位</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要阐述个人对&lt;strong&gt;nginx&lt;/strong&gt;的核心机制–事件驱动框架理解,分享自己的见得。也希望帮助相关爱好者更清除的了解nginx。文中如有不妥的地方，欢迎指导更正。&lt;/p&gt;
&lt;p&gt;首先先了解下，目前流行的web server中，使用最广的Apache在处理请求时，主要是fork出子进程进行处理，其特征就是一个请求占用一个子进程，请求处理完后进程退出销毁。这种处理架构很明显地随着需要http连接增多对系统的资源占用也随之增加，并发能力不高。而对于nginx是如何做到高性能，高并发的呢–nginx的强大就是使用了事件驱动，也就是IO多路复用。对于nginx的几个worker进程而言，她们关注的是事件。（本文主要探讨的是linux环境下使用epoll模块的IO多路复用）&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://www.perfgao.xin/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://www.perfgao.xin/tags/nginx/"/>
    
      <category term="事件驱动" scheme="http://www.perfgao.xin/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="epoll" scheme="http://www.perfgao.xin/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>HEXO -- Hello World</title>
    <link href="http://www.perfgao.xin/2017/03/03/hello-world/"/>
    <id>http://www.perfgao.xin/2017/03/03/hello-world/</id>
    <published>2017-03-03T13:12:01.000Z</published>
    <updated>2018-03-28T13:34:42.239Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
