{"meta":{"title":"perfgao","subtitle":null,"description":null,"author":"perfgao","url":"http://www.perfgao.xin"},"pages":[{"title":"","date":"2018-03-28T13:34:42.239Z","updated":"2018-03-28T13:34:42.239Z","comments":true,"path":"404.html","permalink":"http://www.perfgao.xin/404.html","excerpt":"","text":""},{"title":"Categories","date":"2018-03-28T13:34:42.240Z","updated":"2018-03-28T13:34:42.240Z","comments":true,"path":"categories/index.html","permalink":"http://www.perfgao.xin/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-03-28T13:34:42.240Z","updated":"2018-03-28T13:34:42.240Z","comments":true,"path":"about/index.html","permalink":"http://www.perfgao.xin/about/index.html","excerpt":"","text":"这是我的个人博客。 如果有相关的问题等，欢迎留言交流，或则是邮件交流。 我的邮箱是：**perfgao@gmail.com**"},{"title":"Tags","date":"2018-03-28T13:34:42.242Z","updated":"2018-03-28T13:34:42.242Z","comments":true,"path":"tags/index.html","permalink":"http://www.perfgao.xin/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"perfgao","slug":"perfgao","date":"2018-03-28T15:10:56.000Z","updated":"2018-03-28T15:10:56.910Z","comments":true,"path":"2018/03/28/perfgao/","link":"","permalink":"http://www.perfgao.xin/2018/03/28/perfgao/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"nginx的时间管理","slug":"ngx_time_manege","date":"2017-04-04T14:09:10.000Z","updated":"2018-03-28T13:34:42.240Z","comments":true,"path":"2017/04/04/ngx_time_manege/","link":"","permalink":"http://www.perfgao.xin/2017/04/04/ngx_time_manege/","excerpt":"本文主要以work进程为主要研究对象，研究其在epoll模式下的时间管理逻辑。 时间缓存nginx 为尽量减少性能损耗，对时间的管理，采用了自己对时间进行缓存，以减少系统调用次数(时间更新使用gettimeofday函数)。这样做也是因为服务器基本对时间的精确度有个容忍度。 三类事件触发时间更新 网络IO事件 超时事件 定时事件","text":"本文主要以work进程为主要研究对象，研究其在epoll模式下的时间管理逻辑。 时间缓存nginx 为尽量减少性能损耗，对时间的管理，采用了自己对时间进行缓存，以减少系统调用次数(时间更新使用gettimeofday函数)。这样做也是因为服务器基本对时间的精确度有个容忍度。 三类事件触发时间更新 网络IO事件 超时事件 定时事件 关于指令timer_resolutionwork进程对时间的更新在每次的epool_wait结束。在没有配置timer_resolution时，是通过网络IO事件和超时事件来触发更新。这种情况下时间的更新就与网络IO事件和超时事件息息相关。在某些情况下，比如没有超时事件注册，且没有网络IO事件发生，epoll_wait有会一直等待。想要准确的更新时间，nginx就提供了指令timer_resolution来设置获取时间的周期值。当配置了timer_resolution时，则是通过定时事件来触发时间更新的。 1timer_resolution 100ms; 即是通过指定参数来设置更新频率。这种情况下，epoll_wait会阻塞等待一直到读写事件发生或则信号中断(注意此时没有超时时间)。另外，看过一些资料说现在x86_64对gettimeofday函数的调用开销很小，所以在配置nginx时可以根据需要来决定是否配置该指令或设定适当更新时间的间隔。 从未配置timer_resolution谈起nginx在master/workers下，每个进程都会维护自己的时间。这里主要看下work进程的时间管理逻辑。工作进程的主要工作函数在ngx_worker_process_cycle:123456789static voidngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)&#123; for ( ;; ) &#123; ngx_process_events_and_timers(cycle); &#125;&#125; 每个子进程在进行一系列初始化工作之后，会进入到处理事件的循环中。在循环中会调用 ngx_process_events_and_timers;该函数是工作进程的核心函数，这里主要看时间相关的逻辑。123456789101112131415voidngx_process_events_and_timers(ngx_cycle_t *cycle)&#123; if (ngx_timer_resolution) &#123; timer = NGX_TIMER_INFINITE; // 宏，值为 -1 flags = 0; &#125; else &#123; timer = ngx_event_find_timer(); //获取离现在最近的超时定时器时间 flags = NGX_UPDATE_TIME; &#125; (void) ngx_process_events(cycle, timer, flags);&#125; 她会对ngx_timer_resolution进行判断(注意：配置了timer_resolution，则ngx_timer_resolution为配置的时间值，未配置则ngx_timer_resolution值为0). 在没有配置情况下，通过ngx_event_find_timer获取最近的超时时间,flag赋值为NGX_UPDATE_TIME。之后传入ngx_process_events中：1(void) ngx_process_events(cycle, timer, flags); 它是一个钩子函数。linux下，nginx use epoll下，事件为普通网络IO套接字，则调用为：ngx_epoll_process_events;事件为异步文件i/o，则调用为： ngx_epoll_eventfd_handler 这里主要看下在ngx_epoll_process_events：123456789101112static ngx_int_tngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)&#123; events = epoll_wait(ep, event_list, (int) nevents, timer); if (flags &amp; NGX_UPDATE_TIME || ngx_event_timer_alarm) &#123; ngx_time_update(); &#125; for (i = 0; i &lt; events; i++) &#123; &#125;&#125; 在ngx_epoll_process_events中会调用epoll_wait. 在没有设置 ngx_timer_resolution情况下，则传入的timer为获取的最近的超时时间，这样在epoll_wait即使没有读写事件发生，也会触发超时。不管是读写事件还是超时事件，都会因为传入的flag为NGX_UPDATE_TIME，而进行时间的更新。 配置timer_resolution下的时间管理这种情况下的时间更新逻辑，要从子进程创建开始：nginx在创建子进程时，每个子进程初始化时会调用：ngx_event_process_init();12345678910111213141516171819202122232425262728293031static ngx_int_tngx_event_process_init(ngx_cycle_t *cycle)&#123; if (ngx_timer_resolution &amp;&amp; !(ngx_event_flags &amp; NGX_USE_TIMER_EVENT)) &#123; struct sigaction sa; struct itimerval itv; ngx_memzero(&amp;sa, sizeof(struct sigaction)); sa.sa_handler = ngx_timer_signal_handler; sigemptyset(&amp;sa.sa_mask); if (sigaction(SIGALRM, &amp;sa, NULL) == -1) &#123; ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno, &quot;sigaction(SIGALRM) failed&quot;); return NGX_ERROR; &#125; itv.it_interval.tv_sec = ngx_timer_resolution / 1000; itv.it_interval.tv_usec = (ngx_timer_resolution % 1000) * 1000; itv.it_value.tv_sec = ngx_timer_resolution / 1000; itv.it_value.tv_usec = (ngx_timer_resolution % 1000 ) * 1000; if (setitimer(ITIMER_REAL, &amp;itv, NULL) == -1) &#123; ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno, &quot;setitimer() failed&quot;); &#125; &#125;&#125; 这里就会判断，若是指定了更新时间值，则该进程会设置一个定时器，并设置该进程的信号处理函数为ngx_timer_signal_handler:12345void ngx_timer_signal_handler(int signo) &#123; ngx_event_timer_alarm = 1; &#125; 结合以上ngx_worker_process_cycle和ngx_process_events_and_timers逻辑，进入ngx_process_events_and_timers时，会把timer设置为-1,flag为0。即传入ngx_epoll_process_events的timer为-1,flag为0。timer为-1使epoll_wait为永远等待，直到有读写事件发生。当有读写事件发生后，又由于flag为0，且此时若是ngx_event_timer_alarm为0,则不可能进入到时间更新。而当定时时间到达时，信号处理函数就会设置ngx_event_timer_alarm为1，同时SIGALRM信号会使处于等待的epoll_wait中断，这样便会更新时间了。 最后在说下setitimer()setitimer(), 是linux的API函数。它本身有两个作用： 指定一段时间后才执行某个函数 指定每隔一段时间就执行某个函数 当setitimer到时就会触发SIGALRM信号。而是要完成哪种作用效果， 则是struct itimerva的设置了。","categories":[{"name":"nginx","slug":"nginx","permalink":"http://www.perfgao.xin/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.perfgao.xin/tags/nginx/"},{"name":"timer","slug":"timer","permalink":"http://www.perfgao.xin/tags/timer/"},{"name":"时间管理","slug":"时间管理","permalink":"http://www.perfgao.xin/tags/时间管理/"}]},{"title":"nginx 防止惊群","slug":"jingqun","date":"2017-03-24T10:43:21.000Z","updated":"2018-03-28T13:34:42.239Z","comments":true,"path":"2017/03/24/jingqun/","link":"","permalink":"http://www.perfgao.xin/2017/03/24/jingqun/","excerpt":"惊群 惊群现象就是多个进程同时等待同一个事件，当有事件发生时，所有进程都被唤醒，同时去响应这个事件，最后只有一个进程能成功执行，而其他进程只能继续重新休眠。nginx 在master/workers模型下，多个worker进程进行epoll_wait，当有新的连接事件发生，会唤醒所有进程的epoll_wait，结果有些进程发现accpte是失败的。这样的话，开销变大，性能也会随之下降。","text":"惊群 惊群现象就是多个进程同时等待同一个事件，当有事件发生时，所有进程都被唤醒，同时去响应这个事件，最后只有一个进程能成功执行，而其他进程只能继续重新休眠。nginx 在master/workers模型下，多个worker进程进行epoll_wait，当有新的连接事件发生，会唤醒所有进程的epoll_wait，结果有些进程发现accpte是失败的。这样的话，开销变大，性能也会随之下降。 nginx的解决方案解决这个问题的方案总结下来就是一句话：同一时刻只允许有一个worker进程将需要监听的句柄加入到自己的epoll中。 accpet锁机制通过使用加锁的机制，来做进程间的协调。如果开启了accept锁，则每个worker进程每次在进入epoll_wait获取事件之前，会进行尝试获取锁。只有获取到锁的worker进程才能将需要监听的句柄加入到自己的epoll中，进而去处理accpet事件。不过，这里要注意几个逻辑： 如果该worker进程获取锁成功： 并且其上一次尝试获得锁是失败的（即上一次没有获得到锁），才会将现有的cycle-&gt;listening数组中需要监听的句柄加入到自己的epoll中， 要是上一次尝试获得锁也是成功的（即上一次该进程得到了锁，这次仍是该进程拥有），则会直接返回。 如果该worker进程获取锁失败， 并且其上一次尝试获得锁也是失败的，则会直接返回。 如果其上一次尝试获得锁是成功的，则会将现有的cycle-&gt;listening数组中已经监听的句柄从自己的epoll中移除。 POST事件对于得到锁的进程，会携带NGX_POST_EVENTS标记属性。这样在epoll_wait后，会把需要处理的事件先加入到队列中，延迟处理，目的就是避免该进程长时间占有锁。特别说明一下，这里的延迟队列分为两种： accept事件的延迟队列 read/write事件的延迟队列 也就是对应的事件会加到对应的延迟队列中。进程在释放锁之前，会先处理accept事件的延迟队列，处理完后才会释放锁，然后再去处理超时事件和read/write事件的延迟队列，这样既保证的处理accpet的可靠性，也避免了长时间对锁的占用。 未得到锁的进程与此同时，未得到锁的进程会在epoll_wait下至少等待ngx_accept_mutex_delay毫秒，因为有可能超时事件的发生时间会短与ngx_accept_mutex_delay，也有可能有普通的读写事件触发。总之，该进程会更新进程时间缓存，处理相关的事件。然后再次尝试锁的获取。 指令 accept_mutex 默认是打开。 与它相关的指令： accept_mutex_delay – 默认 500 毫秒 看下代码逻辑实现 ngx_use_accept_mutex: 当开启了accept_mutex，且worker进程数 &gt; 1, ngx_use_accept_mutex会置为1 ngx_process_events 是一个函数指针。普通网络套接字调用ngx_epoll_process_events函数开始处理，异步文件i/o设置事件的回调方法为ngx_epoll_eventfd_handler。这里主要看下ngx_epoll_process_events函数逻辑。 注意：这里仅仅是为了方便阅读，只是展现了大概的代码逻辑，省略了部分代码。 1234567891011121314151617181920212223242526272829303132333435voidngx_process_events_and_timers(ngx_cycle_t *cycle)&#123; if (ngx_use_accept_mutex) &#123; if (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123; return; &#125; if (ngx_accept_mutex_held) &#123; flags |= NGX_POST_EVENTS; &#125; else &#123; if (timer == NGX_TIMER_INFINITE || timer &gt; ngx_accept_mutex_delay) &#123; timer = ngx_accept_mutex_delay; &#125; &#125; &#125; (void) ngx_process_events(cycle, timer, flags); ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events); if (ngx_accept_mutex_held) &#123; ngx_shmtx_unlock(&amp;ngx_accept_mutex); &#125; if (delta) &#123; ngx_event_expire_timers(); &#125; ngx_event_process_posted(cycle, &amp;ngx_posted_events);&#125; 123456789101112131415161718192021222324252627282930ngx_int_tngx_trylock_accept_mutex(ngx_cycle_t *cycle)&#123; if (ngx_shmtx_trylock(&amp;ngx_accept_mutex)) &#123; if (ngx_accept_mutex_held &amp;&amp; ngx_accept_events == 0) &#123; return NGX_OK; &#125; if (ngx_enable_accept_events(cycle) == NGX_ERROR) &#123; ngx_shmtx_unlock(&amp;ngx_accept_mutex); return NGX_ERROR; &#125; ngx_accept_events = 0; ngx_accept_mutex_held = 1; return NGX_OK; &#125; if (ngx_accept_mutex_held) &#123; if (ngx_disable_accept_events(cycle, 0) == NGX_ERROR) &#123; return NGX_ERROR; &#125; ngx_accept_mutex_held = 0; &#125; return NGX_OK;&#125; 12345678910111213141516171819202122232425262728293031323334static ngx_int_tngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)&#123; events = epoll_wait(ep, event_list, (int) nevents, timer); ngx_time_update(); for (i = 0; i &lt; events; i++) &#123; if ((revents &amp; EPOLLIN) &amp;&amp; rev-&gt;active) &#123; if (flags &amp; NGX_POST_EVENTS) &#123; queue = rev-&gt;accept ? &amp;ngx_posted_accept_events : &amp;ngx_posted_events; ngx_post_event(rev, queue); &#125; else &#123; rev-&gt;handler(rev); &#125; &#125; if ((revents &amp; EPOLLOUT) &amp;&amp; wev-&gt;active) &#123; if (flags &amp; NGX_POST_EVENTS) &#123; ngx_post_event(wev, &amp;ngx_posted_events); &#125; else &#123; wev-&gt;handler(wev); &#125; &#125; &#125;&#125;","categories":[{"name":"nginx","slug":"nginx","permalink":"http://www.perfgao.xin/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.perfgao.xin/tags/nginx/"},{"name":"惊群","slug":"惊群","permalink":"http://www.perfgao.xin/tags/惊群/"}]},{"title":"nginx事件驱动框架","slug":"nginx事件驱动框架","date":"2017-03-17T10:34:23.000Z","updated":"2018-03-28T13:34:42.239Z","comments":true,"path":"2017/03/17/nginx事件驱动框架/","link":"","permalink":"http://www.perfgao.xin/2017/03/17/nginx事件驱动框架/","excerpt":"本文主要阐述个人对nginx的核心机制–事件驱动框架理解,分享自己的见得。也希望帮助相关爱好者更清除的了解nginx。文中如有不妥的地方，欢迎指导更正。 首先先了解下，目前流行的web server中，使用最广的Apache在处理请求时，主要是fork出子进程进行处理，其特征就是一个请求占用一个子进程，请求处理完后进程退出销毁。这种处理架构很明显地随着需要http连接增多对系统的资源占用也随之增加，并发能力不高。而对于nginx是如何做到高性能，高并发的呢–nginx的强大就是使用了事件驱动，也就是IO多路复用。对于nginx的几个worker进程而言，她们关注的是事件。（本文主要探讨的是linux环境下使用epoll模块的IO多路复用）","text":"本文主要阐述个人对nginx的核心机制–事件驱动框架理解,分享自己的见得。也希望帮助相关爱好者更清除的了解nginx。文中如有不妥的地方，欢迎指导更正。 首先先了解下，目前流行的web server中，使用最广的Apache在处理请求时，主要是fork出子进程进行处理，其特征就是一个请求占用一个子进程，请求处理完后进程退出销毁。这种处理架构很明显地随着需要http连接增多对系统的资源占用也随之增加，并发能力不高。而对于nginx是如何做到高性能，高并发的呢–nginx的强大就是使用了事件驱动，也就是IO多路复用。对于nginx的几个worker进程而言，她们关注的是事件。（本文主要探讨的是linux环境下使用epoll模块的IO多路复用） 网络IO处理使用epoll机制(本文主要探究epoll，对于freebsd的kqueue不做探究)。对网络请求的socket进行epoll监听，使用epoll_wait（在ET或LT模式下）来获取需要处理的事件。 定时器定时器是由红黑树构成，其中每个节点都是一个时间值。这样每次从树中取出一个最小值的节点与当前系统时间做对比，若是小于当期时间则是超时事件，便会触发相应的超时处理。 事件的划分对于accept成功的socket，之后应该是从客户端（浏览器）读取请求，读取请求的时候，若是请求体比较大，可能会经过几次的触发才能读取完。读取完后，就要与上游服务器建立连接，在tcp建立连接的三次握手过程中，加之复杂的网络环境（有可能建立需要花费较长的时间），nginx不可能阻塞着，这时候nginx会将socket加入到epoll中，并设定一个超时时间在定时器中。一旦在有效时间内上游服务器有回应了，便会触发接下来的继续执行。若是超时了，nginx就会进行连接超时的相关处理（此时若是使用的upstream，便会执行向其他上游服务ip的连接流程）。连接建立成功后，nginx会向上游发送请求。请求发送完后，便是接收上游发来的响应。这些过程中，nginx都不会阻塞着等待期待到来的事件发生，而都是加入到epoll中进行监听，并添加相应的超时事件。 123456789static voidngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n, ngx_int_t type)&#123; for ( ;; ) &#123; ngx_event_cancel_timers(); &#125;&#125; 123456789voidngx_process_events_and_timers(ngx_cycle_t *cycle) &#123; timer = ngx_event_find_timer(); (void) ngx_process_events(cycle, timer, flags); ngx_event_expire_timers();&#125; 123456789101112131415static ngx_int_tngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)&#123; events = epoll_wait(ep, event_list, (int) nevents, timer); for (i = 0; i &lt; events; i++) &#123; if ((revents &amp; EPOLLIN) &amp;&amp; rev-&gt;active) &#123; rev-&gt;handler(rev); &#125; if ((revents &amp; EPOLLOUT) &amp;&amp; wev-&gt;active) &#123; wev-&gt;handler(wev); &#125; &#125;&#125; 12345678910111213141516171819202122232425voidngx_event_expire_timers(void)&#123; sentinel = ngx_event_timer_rbtree.sentinel; for ( ;; ) &#123; root = ngx_event_timer_rbtree.root; if (root == sentinel) &#123; return; &#125; node = ngx_rbtree_min(root, sentinel); if ((ngx_msec_int_t) (node-&gt;key - ngx_current_msec) &gt; 0) &#123; return; &#125; ngx_rbtree_delete(&amp;ngx_event_timer_rbtree, &amp;ev-&gt;timer); ev-&gt;timer_set = 0; ev-&gt;timedout = 1; ev-&gt;handler(ev); &#125;&#125; ngx_event_t 结构体中有一些标记位，不同的状态对应不同的标志位","categories":[{"name":"nginx","slug":"nginx","permalink":"http://www.perfgao.xin/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.perfgao.xin/tags/nginx/"},{"name":"事件驱动","slug":"事件驱动","permalink":"http://www.perfgao.xin/tags/事件驱动/"},{"name":"epoll","slug":"epoll","permalink":"http://www.perfgao.xin/tags/epoll/"}]},{"title":"HEXO -- Hello World","slug":"hello-world","date":"2017-03-03T13:12:01.000Z","updated":"2018-03-28T13:34:42.239Z","comments":true,"path":"2017/03/03/hello-world/","link":"","permalink":"http://www.perfgao.xin/2017/03/03/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}